\documentclass[12pt,a4paper]{article}
\usepackage[margin=1in]{geometry}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{amsmath}

\definecolor{codegray}{rgb}{0.95,0.95,0.95}
\definecolor{keyword}{rgb}{0.36,0.36,0.8}

\lstdefinestyle{myCStyle}{
    backgroundcolor=\color{codegray},
    keywordstyle=\color{keyword}\bfseries,
    language=C++,
    basicstyle=\ttfamily\small,
    numbers=left,
    numberstyle=\tiny,
    stepnumber=1,
    numbersep=5pt,
    showstringspaces=false,
    tabsize=4,
    breaklines=true,
}

\title{Mastering Enum Classes in Embedded C++}
\author{Prepared by: MD. Jesan}
\date{\today}

\begin{document}
\maketitle

\section*{Introduction}
Think of \textbf{enum classes} as giving "nicknames" to numbers. Instead of remembering 0, 1, 2 for LED colors or pin numbers, you give them meaningful names. In embedded systems, this makes your code safe and easy to read.

\textbf{Why use enum classes in embedded systems?}
\begin{itemize}
    \item Type-safe: Prevents mixing unrelated numbers with pins or registers.
    \item Scoped: Values belong to the enum only, avoiding name conflicts.
    \item Can define underlying types (like \texttt{uint8\_t}), perfect for hardware registers.
\end{itemize}

\section*{Basic Syntax}
\begin{lstlisting}[style=myCStyle]
enum class LED : uint8_t {
    RED = 0,
    GREEN = 1,
    BLUE = 2
};
\end{lstlisting}

\section*{Accessing Enum Values}
\begin{lstlisting}[style=myCStyle]
LED myLed = LED::RED;

// To use as a number (for registers), use static_cast
uint8_t ledVal = static_cast<uint8_t>(myLed);
\end{lstlisting}

\section*{Embedded Example: Direct Register Access}
In embedded C++, you often need to manipulate memory addresses of hardware registers. Here, we use \texttt{reinterpret\_cast} to safely convert a number to a pointer.

\begin{lstlisting}[style=myCStyle]
// Define ports as constant pointers using reinterpret_cast
constexpr volatile uint8_t* PORTB_PTR = reinterpret_cast<volatile uint8_t*>(0x25);
constexpr volatile uint8_t* DDRB_PTR  = reinterpret_cast<volatile uint8_t*>(0x24);

// Set PB5 as output
*DDRB_PTR |= (1 << 5);

// Toggle PB5
*PORTB_PTR ^= (1 << 5);
\end{lstlisting}

\textbf{Explanation for kids:}
\begin{itemize}
    \item \texttt{reinterpret\_cast<volatile uint8\_t*>(0x25)} says: "Hey, treat this number (0x25) as the address of a register!"
    \item \texttt{*PORTB\_PTR} accesses the actual memory at that address.
    \item \texttt{static\_cast<uint8\_t>(PIN::PB5)} converts the enum PIN number into a number we can use in bit operations.
\end{itemize}

\section*{Using Enum Classes for Pins}
\begin{lstlisting}[style=myCStyle]
enum class PIN : uint8_t {
    PB5 = 5,
    PB4 = 4
};

// Toggle LED on PB5
*PORTB_PTR ^= (1 << static_cast<uint8_t>(PIN::PB5));
\end{lstlisting}

\section*{Why static\_cast is needed}
Enum class values are type-safe. You can't directly use them in arithmetic or bitwise operations. So we convert them to integers using \texttt{static\_cast}.

\section*{Summary}
\begin{itemize}
    \item Enum classes give readable names to numbers.
    \item Use \texttt{reinterpret\_cast} to turn a number into a pointer to a hardware register.
    \item Use \texttt{static\_cast} to convert enum values to integers for bit operations.
    \item Makes embedded code safer, clearer, and less prone to errors.
\end{itemize}


\newpage
\section*{Deep Dive: Understanding the getReg() Function}

This section explains the following function in complete detail:

\begin{lstlisting}[style=myCStyle]
volatile uint8_t & getReg(Register reg)
{
    return *reinterpret_cast<volatile uint8_t*>(static_cast<uint8_t>(reg));
}
\end{lstlisting}

Let's break it down step by step, from inside out.

\subsection*{Step 1: static\_cast<uint8\_t>(reg)}

\begin{lstlisting}[style=myCStyle]
enum class Register : uint8_t {
    TCCR0B = 0x25  // This is stored as the number 37 (0x25 in hex)
};
\end{lstlisting}

\textbf{Why static\_cast?}
\begin{itemize}
    \item \texttt{enum class} is \textbf{strongly typed} - it won't convert to a number automatically
    \item We need the actual number \texttt{0x25} to use as a memory address
    \item \texttt{static\_cast<uint8\_t>(reg)} converts \texttt{Register::TCCR0B} to \texttt{0x25}
\end{itemize}

\begin{lstlisting}[style=myCStyle]
Register reg = Register::TCCR0B;

uint8_t address = reg;                        // ERROR! enum class won't convert
uint8_t address = static_cast<uint8_t>(reg);  // OK! address = 0x25
\end{lstlisting}

\subsection*{Step 2: reinterpret\_cast<volatile uint8\_t*>(...)}

Now we have the number \texttt{0x25}. But it's just a number, not a pointer.

\textbf{Why reinterpret\_cast?}
\begin{itemize}
    \item We want to treat \texttt{0x25} as a \textbf{memory address} (pointer)
    \item \texttt{reinterpret\_cast} says: "Trust me, this number IS a memory address"
\end{itemize}

\begin{lstlisting}[style=myCStyle]
uint8_t address = 0x25;  // Just a number

volatile uint8_t* ptr = reinterpret_cast<volatile uint8_t*>(address);
// Now ptr points to memory location 0x25
\end{lstlisting}

\textbf{Visual representation:}
\begin{verbatim}
Memory:
Address:  0x24   0x25   0x26   0x27
          [  ]   [  ]   [  ]   [  ]
                  ^
                 ptr points here
\end{verbatim}

\subsection*{Step 3: The * at the front (Dereference)}

\begin{lstlisting}[style=myCStyle]
return *reinterpret_cast<volatile uint8_t*>(...);
       ^
       This asterisk!
\end{lstlisting}

\textbf{Why *?}
\begin{itemize}
    \item \texttt{reinterpret\_cast<volatile uint8\_t*>(...)} gives us a \textbf{pointer} (an address)
    \item We want to return the \textbf{actual value} at that address, not the address itself
    \item \texttt{*} \textbf{dereferences} the pointer - it "goes to" the address and gets the value
\end{itemize}

\begin{lstlisting}[style=myCStyle]
volatile uint8_t* ptr = reinterpret_cast<volatile uint8_t*>(0x25);
// ptr = 0x25 (an address)

volatile uint8_t value = *ptr;
// value = whatever is stored at address 0x25
\end{lstlisting}

\subsection*{Step 4: Return type volatile uint8\_t \&}

\begin{lstlisting}[style=myCStyle]
volatile uint8_t & getReg(...)
                 ^
                 Reference!
\end{lstlisting}

\textbf{Why return a reference \&?}
\begin{itemize}
    \item We want the caller to be able to \textbf{read AND write} to the register
    \item A reference lets you modify the original value
\end{itemize}

\begin{lstlisting}[style=myCStyle]
// Without reference (just value) - can only READ
uint8_t value = getReg(Register::TCCR0B);  // Gets a copy
value = 5;  // Only changes the copy, not the register!

// With reference - can READ and WRITE
getReg(Register::TCCR0B) = 5;              // Directly changes the register!
getReg(Register::TCCR0B) |= (1 << 2);      // Modifies the register!
\end{lstlisting}

\subsection*{Complete Flow Example}

\begin{lstlisting}[style=myCStyle]
getReg(Register::TCCR0B) |= (1 << 2);
\end{lstlisting}

\begin{enumerate}
    \item \texttt{Register::TCCR0B} - enum value
    \item \texttt{static\_cast<uint8\_t>(...)} - converts to \texttt{0x25} (number)
    \item \texttt{reinterpret\_cast<volatile uint8\_t*>(...)} - pointer to address \texttt{0x25}
    \item \texttt{*} - dereference to get the value at that address
    \item \texttt{\&} - return as reference so caller can modify it
    \item \texttt{|= (1 << 2)} - modify the actual hardware register!
\end{enumerate}

\subsection*{Visual Summary}

\begin{verbatim}
Register::TCCR0B
       |
       v
static_cast<uint8_t>  -->  0x25 (just a number)
       |
       v
reinterpret_cast<volatile uint8_t*>  -->  0x25 (now it's a pointer)
       |
       v
* (dereference)  -->  actual value at memory 0x25
       |
       v
& (reference)  -->  caller can read/write directly
\end{verbatim}

\subsection*{Pointer vs Reference: Simple Analogy}

\textbf{Pointer (*):} Your friend gives you the address of their house. You have to go there first to access it.

\textbf{Reference (\&):} Your friend hands you the keys to their house directly. You can use it right away.

\begin{lstlisting}[style=myCStyle]
// Pointer version - need to dereference
volatile uint8_t * getReg(Register reg) {
    return reinterpret_cast<volatile uint8_t*>(static_cast<uint8_t>(reg));
}
*getReg(Register::TCCR0B) |= (1 << 2);  // Need * to access

// Reference version - direct access
volatile uint8_t & getReg(Register reg) {
    return *reinterpret_cast<volatile uint8_t*>(static_cast<uint8_t>(reg));
}
getReg(Register::TCCR0B) |= (1 << 2);   // No * needed!
\end{lstlisting}

\textbf{Best Practice:} Use \textbf{reference} because it's simpler and safer!


\newpage
\section*{Creating a Delay Function Using Timer0}

In this section, we will create a precise 1ms delay function using Timer0 on the ATmega328P.

\subsection*{The Math Behind the Delay}

To create a delay, we need to understand how the timer counts:

\begin{enumerate}
    \item \textbf{CPU Frequency:} The ATmega328P runs at 16 MHz (16,000,000 Hz)
    \item \textbf{Prescaler:} We divide the clock to slow down counting
    \item \textbf{Timer Register:} TCNT0 is an 8-bit counter (0-255)
\end{enumerate}

\textbf{Formula:}
$$\text{Timer Frequency} = \frac{F\_CPU}{\text{Prescaler}}$$
$$\text{Time per tick} = \frac{1}{\text{Timer Frequency}}$$
$$\text{Ticks needed} = \frac{\text{Desired Time}}{\text{Time per tick}}$$

\subsection*{Calculation for 1ms Delay}

Let's use a prescaler of 64:

$$\text{Timer Frequency} = \frac{16,000,000}{64} = 250,000 \text{ Hz}$$

$$\text{Time per tick} = \frac{1}{250,000} = 4 \mu s$$

$$\text{Ticks for 1ms} = \frac{1000 \mu s}{4 \mu s} = 250 \text{ ticks}$$

So we need to count 250 ticks to get exactly 1ms!

\subsection*{Why We Reset TCNT0}

\begin{lstlisting}[style=myCStyle]
getReg(Register::TCNT0) = 0;  // Reset counter to 0
\end{lstlisting}

\textbf{Why reset TCNT0?}
\begin{itemize}
    \item TCNT0 is the Timer Counter register - it counts up automatically
    \item If we don't reset it, it might start from any value (0-255)
    \item Resetting ensures we always count from 0 to 250 for accurate timing
    \item Without reset: unpredictable delay times!
\end{itemize}

\textbf{Visual:}
\begin{verbatim}
Without reset:          With reset:
TCNT0 = 100             TCNT0 = 0
  |                       |
  v                       v
Count to 250            Count to 250
  |                       |
  v                       v
Only 150 ticks!         Exactly 250 ticks!
(0.6ms - WRONG!)        (1ms - CORRECT!)
\end{verbatim}

\subsection*{Why Compare with < 250, not <= 250?}

\begin{lstlisting}[style=myCStyle]
while(getReg(Register::TCNT0) < 250)   // Correct: 0 to 249 = 250 ticks
while(getReg(Register::TCNT0) <= 250)  // Wrong: 0 to 250 = 251 ticks
\end{lstlisting}

\textbf{Explanation:}
\begin{itemize}
    \item Counter starts at 0
    \item \texttt{< 250}: Loop runs while counter is 0, 1, 2, ... 249 (250 values = 250 ticks)
    \item \texttt{<= 250}: Loop runs while counter is 0, 1, 2, ... 250 (251 values = 251 ticks)
\end{itemize}

Think of it like counting on your fingers:
\begin{itemize}
    \item Fingers 0-249 = 250 fingers (correct!)
    \item Fingers 0-250 = 251 fingers (one too many!)
\end{itemize}

\subsection*{Complete delayms() Function}

\begin{lstlisting}[style=myCStyle]
void delayms(uint16_t ms)
{
    // Prescaler 64: CS01=1, CS00=1
    getReg(Register::TCCR0B) = (1 << Bits::CS00) | (1 << Bits::CS01);
    
    while(ms--)
    {
        // Reset timer counter to 0
        getReg(Register::TCNT0) = 0;
        
        // 16MHz / 64 = 250,000 Hz
        // 1 tick = 4us
        // 250 ticks = 1ms
        while(getReg(Register::TCNT0) < 250)
        {
            // Wait
        }
    }
}
\end{lstlisting}

\subsection*{Prescaler Selection Table}

\begin{center}
\begin{tabular}{|c|c|c|c|c|}
\hline
\textbf{CS02} & \textbf{CS01} & \textbf{CS00} & \textbf{Prescaler} & \textbf{Timer Freq (16MHz)} \\
\hline
0 & 0 & 0 & No clock & Timer stopped \\
0 & 0 & 1 & 1 & 16 MHz \\
0 & 1 & 0 & 8 & 2 MHz \\
0 & 1 & 1 & 64 & 250 kHz \\
1 & 0 & 0 & 256 & 62.5 kHz \\
1 & 0 & 1 & 1024 & 15.625 kHz \\
\hline
\end{tabular}
\end{center}

\subsection*{Step-by-Step Flow}

\begin{enumerate}
    \item Set prescaler to 64 (TCCR0B = CS01 | CS00)
    \item For each millisecond:
    \begin{enumerate}
        \item Reset TCNT0 to 0
        \item Wait until TCNT0 reaches 250
        \item Repeat for next millisecond
    \end{enumerate}
\end{enumerate}

\textbf{Visual Flow:}
\begin{verbatim}
delayms(3) called:

ms=3: TCNT0: 0 -> 1 -> 2 -> ... -> 249 (1ms) done!
ms=2: TCNT0: 0 -> 1 -> 2 -> ... -> 249 (1ms) done!
ms=1: TCNT0: 0 -> 1 -> 2 -> ... -> 249 (1ms) done!

Total: 3ms delay complete!
\end{verbatim}


\newpage
\title{Understanding Namespaces in Embedded Programming}
\maketitle

\section*{What is a Namespace?}
Imagine you have a huge toy box full of toys. Sometimes two toys might have the same name, like two "robots" from different sets. To avoid confusion, you put toys from Set A in one small box and toys from Set B in another. Now you know exactly which "robot" you are playing with. 

In C++ programming, a \textbf{namespace} is like that small box. It helps us avoid confusion when we have functions, variables, or classes with the same name.

\begin{itemize}
    \item Namespaces are a way to group code into a named "box."
    \item They prevent name conflicts between different parts of your program.
    \item Especially in embedded programming, where you might deal with registers, peripherals, and different libraries, namespaces help keep your code organized.
\end{itemize}

\section*{Basic Example}
\begin{lstlisting}[style=myCStyle]
// Two sets of LEDs in different namespaces
namespace BoardA {
    void turnOnLED() {
        // Code to turn on LED in Board A
    }
}

namespace BoardB {
    void turnOnLED() {
        // Code to turn on LED in Board B
    }
}

int main() {
    BoardA::turnOnLED(); // Calls the function from Board A
    BoardB::turnOnLED(); // Calls the function from Board B
}
\end{lstlisting}

\textbf{Explanation:} By putting functions in different namespaces, we avoid the compiler getting confused about which \texttt{turnOnLED()} function we mean.

\section*{Namespaces in Embedded Programming}
In embedded systems, you often control hardware directly:
\begin{itemize}
    \item Different modules (like ADC, PWM, GPIO) may have functions with the same names.
    \item Using namespaces lets you group functions for each module separately.
    \item Example: \texttt{GPIO::init()}, \texttt{PWM::init()}, \texttt{ADC::init()}.
\end{itemize}

\section*{Advanced Usage: Nested Namespaces}
You can even have namespaces inside namespaces. It's like putting a smaller box inside a bigger one.

\begin{lstlisting}[style=myCStyle]
namespace BoardA {
    namespace LED {
        void turnOn() { /* turn on LED */ }
    }
}

int main() {
    BoardA::LED::turnOn(); // Nested access
}
\end{lstlisting}

\section*{Why Namespaces are Useful in Embedded Programming}
\begin{enumerate}
    \item \textbf{Avoid Conflicts:} Multiple libraries may define the same function name.
    \item \textbf{Organize Code:} Group functions by hardware modules or features.
    \item \textbf{Maintainability:} Easy to find and modify code.
    \item \textbf{Scalability:} Helpful when projects grow larger.
\end{enumerate}

\section*{Kid-Friendly Summary}
Think of namespaces like toy boxes. Each box has its own toys. You never mix up your Lego robot with your Transformers robot because they are in separate boxes. Similarly, namespaces keep your code clean, organized, and safe from name conflicts.


\end{document}
